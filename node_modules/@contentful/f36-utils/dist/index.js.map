{"version":3,"sources":["../src/Portal/Portal.tsx","../src/useKeyboard/useKeyboard.ts","../src/getStringMatch/getStringMatch.ts","../src/hexToRGBA/hexToRGBA.ts","../src/getTextFromChildren/getTextFromChildren.ts","../src/useDensity/useDensity.ts"],"names":["useEffect","useRef","createPortal","Portal","children","containerElement","container","portal","portalContainer","useCallback","useKeyboard","props","ref","keys","event","element","handleKeyEvent","e","getStringMatch","base","match","matchResult","escapedMatch","regex","matches","hexToRGBA","hex","alpha","r","g","b","Children","isValidElement","hasChildren","getTextFromChildren","string","child","React","DensityContext","useDensity","DensityProvider"],"mappings":"AAAA,OAAS,aAAAA,EAAW,UAAAC,MAAc,QAClC,OAAS,gBAAAC,MAAoB,YAUtB,SAASC,EAAO,CACrB,SAAAC,EACA,UAAWC,CACb,EAA0C,CACxC,IAAMC,EAAYL,EAChBI,CACF,EACME,EAASN,EAAuB,SAAS,cAAc,KAAK,CAAC,EAEnE,OAAAD,EAAU,IAAM,CACTM,EAAU,UACbA,EAAU,QAAU,SAAS,MAG/B,IAAME,EAAkBD,EAAO,QAC/B,OAAAC,EAAgB,aAAa,oBAAqB,EAAE,EACpDF,EAAU,QAAQ,YAAYE,CAAe,EAEtC,IAAM,CACPF,EAAU,SACZA,EAAU,QAAQ,YAAYE,CAAe,CAEjD,CACF,EAAG,CAAC,CAAC,EAEED,EAAO,QAAUL,EAAaE,EAAUG,EAAO,OAAO,EAAI,IACnE,CCrCA,OAAS,aAAAP,EAAW,eAAAS,EAA+B,UAAAR,MAAc,QAmC1D,IAAMS,EAAeC,GAA4B,CACtD,GAAM,CAAE,IAAAC,EAAK,KAAAC,EAAM,MAAAC,EAAQ,SAAU,EAAIH,EACnCI,EAAUd,EAA+B,QAAQ,EAEjDe,EAAiBP,EACpBQ,GAAM,CACS,OAAO,UAAU,eAAe,KAAKJ,EAAMI,EAAE,GAAG,GAE5DJ,EAAKI,EAAE,GAAG,EAAEA,CAAC,CAEjB,EACA,CAACJ,CAAI,CACP,EAEAb,EAAU,KACJY,GAAOA,EAAI,UACbG,EAAQ,QAAUH,EAAI,SAGxBG,EAAQ,QAAQ,iBAAiBD,EAAOE,CAAc,EAE/C,IAAM,CACXD,EAAQ,QAAQ,oBAAoBD,EAAOE,CAAc,CAC3D,GACC,CAACF,EAAOE,EAAgBJ,CAAG,CAAC,CACjC,EC5CO,SAASM,EAAeC,EAAcC,EAAyB,CACpE,IAAMC,EAAc,CAAE,OAAQ,GAAI,MAAO,GAAI,MAAO,EAAG,EACjDC,EAAeF,EAAM,QAAQ,sBAAuB,MAAM,EAE1DG,EAAQ,IAAI,OAChB,0BAA0BD,CAAY,gBACtC,GACF,EACME,EAAUL,EAAK,MAAMI,CAAK,EAEhC,OAAIC,IACFH,EAAY,OAASG,EAAQ,OAAO,OACpCH,EAAY,MAAQG,EAAQ,OAAO,MACnCH,EAAY,MAAQG,EAAQ,OAAO,OAG9BH,CACT,CCzBO,SAASI,EAAUC,EAAaC,EAAQ,EAAG,CAChD,IAAMC,EAAI,SAASF,EAAI,MAAM,EAAG,CAAC,EAAG,EAAE,EAChCG,EAAI,SAASH,EAAI,MAAM,EAAG,CAAC,EAAG,EAAE,EAChCI,EAAI,SAASJ,EAAI,MAAM,EAAG,CAAC,EAAG,EAAE,EAEtC,MAAO,QAAQE,CAAC,KAAKC,CAAC,KAAKC,CAAC,KAAKH,CAAK,GACxC,CCdA,OACE,YAAAI,EACA,kBAAAC,MAGK,QAEP,SAASC,EACPlB,EACgE,CAChE,OAAOiB,EAAejB,CAAO,GAAK,EAAQA,EAAQ,MAAM,QAC1D,CASO,SAASmB,EAAoB9B,EAAqB,CACvD,IAAI+B,EAAS,GAEb,OAAAJ,EAAS,QAAQ3B,CAAQ,EAAE,IAAKgC,GAAU,CACpCJ,EAAeI,CAAK,GAAKH,EAAYG,CAAK,EAC5CD,GAAUD,EAAoBE,EAAM,MAAM,QAAQ,GACzC,OAAOA,GAAU,UAAY,OAAOA,GAAU,YACvDD,EAAS,GAAGA,CAAM,GAAGC,CAAK,GAE9B,CAAC,EAEMD,CACT,CChCA,OAAOE,MAAW,QAIlB,IAAMC,EAAiBD,EAAM,cAAuB,KAAK,EAM5CE,EAAa,IACRF,EAAM,WAAWC,CAAc,EAKpCE,EAAkBF,EAAe","sourcesContent":["import { useEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport interface PortalProps {\n  children: React.ReactElement;\n  /**\n   * Container element for Portal\n   */\n  container?: Document | HTMLElement;\n}\n\nexport function Portal({\n  children,\n  container: containerElement,\n}: PortalProps): React.ReactPortal | null {\n  const container = useRef<Document | HTMLElement | undefined>(\n    containerElement,\n  );\n  const portal = useRef<HTMLDivElement>(document.createElement('div'));\n\n  useEffect(() => {\n    if (!container.current) {\n      container.current = document.body;\n    }\n\n    const portalContainer = portal.current;\n    portalContainer.setAttribute('data-cf-ui-portal', '');\n    container.current.appendChild(portalContainer);\n\n    return () => {\n      if (container.current) {\n        container.current.removeChild(portalContainer);\n      }\n    };\n  }, []);\n\n  return portal.current ? createPortal(children, portal.current) : null;\n}\n","import { useEffect, useCallback, MutableRefObject, useRef } from 'react';\n\nexport interface UseKeyboardProps {\n  /**\n   * Object of key names and handlers defines which key to look for i.e. `ArrowUp`, `Escape`, `Shift`\n   * value is a callback function to be called when key matches\n   */\n  keys: {\n    [key: string]: (e: KeyboardEvent) => void;\n  };\n  /**\n   * Defines the attached event type\n   * @default 'keydown'\n   */\n  event?: 'keyup' | 'keypress' | 'keydown';\n\n  /**\n   * React reference to attach the event to its current element\n   */\n  ref?: MutableRefObject<HTMLElement>;\n}\n\n/**\n *\n * @description hook to attach a handler keyboard event listener to `document` or `HTMLElements` with garbage collection\n * @example\n * useKeyboard({\n *  event: 'keydown', // Optional, default is `keydown`\n *  ref: yourReactRef, // Optional, by default event is attached to document\n *  keys: {\n *    ArrowUp: (e) => handleArrowUp(e),\n *    Tab: (e) => handleTab(e)\n *  }\n * })\n */\nexport const useKeyboard = (props: UseKeyboardProps) => {\n  const { ref, keys, event = 'keydown' } = props;\n  const element = useRef<HTMLElement | Document>(document);\n\n  const handleKeyEvent = useCallback(\n    (e) => {\n      const isKey = Object.prototype.hasOwnProperty.call(keys, e.key);\n      if (isKey) {\n        keys[e.key](e);\n      }\n    },\n    [keys],\n  );\n\n  useEffect(() => {\n    if (ref && ref.current) {\n      element.current = ref.current;\n    }\n\n    element.current.addEventListener(event, handleKeyEvent);\n\n    return () => {\n      element.current.removeEventListener(event, handleKeyEvent);\n    };\n  }, [event, handleKeyEvent, ref]);\n};\n","export interface MatchObj {\n  before: string;\n  match: string;\n  after: string;\n}\n\n/**\n * Function that can be used to find a substring inside another string.\n * It needs two strings, the second one will be used in a Regex expression\n * to be matched to the first one.\n * The function will return an object containing the match, what comes before the match,\n * and what comes after the match in the base string\n *\n * @param base\n * @param match\n */\nexport function getStringMatch(base: string, match: string): MatchObj {\n  const matchResult = { before: '', match: '', after: '' };\n  const escapedMatch = match.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  const regex = new RegExp(\n    `(?<before>.*?)(?<match>${escapedMatch})(?<after>.*)`,\n    'i',\n  );\n  const matches = base.match(regex);\n\n  if (matches) {\n    matchResult.before = matches.groups.before;\n    matchResult.match = matches.groups.match;\n    matchResult.after = matches.groups.after;\n  }\n\n  return matchResult;\n}\n","/**\n * Converts a hex color to rgba\n * @param hex - Hex color\n * @param alpha - Alpha value @default 1\n * @returns rgba color\n * @example\n * hexToRGBA('#000000', 0.5)\n */\nexport function hexToRGBA(hex: string, alpha = 1) {\n  const r = parseInt(hex.slice(1, 3), 16);\n  const g = parseInt(hex.slice(3, 5), 16);\n  const b = parseInt(hex.slice(5, 7), 16);\n\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n","import {\n  Children,\n  isValidElement,\n  type ReactElement,\n  type ReactNode,\n} from 'react';\n\nfunction hasChildren(\n  element: ReactNode,\n): element is ReactElement<{ children: ReactNode | ReactNode[] }> {\n  return isValidElement(element) && Boolean(element.props.children);\n}\n\n/**\n * Recursively extracts text and numbers from React children to return as a\n * combined string.\n *\n * @param children - React node to extract text from\n * @returns String with all child nodes' text combined\n */\nexport function getTextFromChildren(children: ReactNode) {\n  let string = '';\n\n  Children.toArray(children).map((child) => {\n    if (isValidElement(child) && hasChildren(child)) {\n      string += getTextFromChildren(child.props.children);\n    } else if (typeof child === 'string' || typeof child === 'number') {\n      string = `${string}${child}`;\n    }\n  });\n\n  return string;\n}\n","import React from 'react';\n\nexport type Density = 'low' | 'high';\n\nconst DensityContext = React.createContext<Density>('low');\n\n/**\n * Use this hook to adapt your component styling/rendering based on the density.\n * The density is retrieved from the `DensityProvider`.\n */\nexport const useDensity = () => {\n  const context = React.useContext(DensityContext);\n\n  return context;\n};\n\nexport const DensityProvider = DensityContext.Provider;\n"]}