import React$1, { ChangeEventHandler, KeyboardEventHandler, FocusEventHandler, ComponentPropsWithoutRef, ReactNode } from 'react';
import { PropsWithHTMLElement, CommonProps, MarginProps, PolymorphicProps, PolymorphicComponent, ExpandProps } from '@contentful/f36-core';
import { Density } from '@contentful/f36-utils';
import { SpacingTokens } from '@contentful/f36-tokens';

interface HelpTextInternalProps extends CommonProps, MarginProps {
    children: React$1.ReactNode;
}
declare type HelpTextProps = PropsWithHTMLElement<HelpTextInternalProps, 'p'>;
/**
 * `HelpText` is a styled copy block with guidance, placed in the context of form components.
 */
declare const HelpText: React$1.ForwardRefExoticComponent<Omit<Omit<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLParagraphElement>, HTMLParagraphElement>, "key" | keyof React$1.HTMLAttributes<HTMLParagraphElement>>, never>, keyof HelpTextInternalProps> & HelpTextInternalProps & React$1.RefAttributes<HTMLParagraphElement>>;

interface ValidationMessageInternalProps extends CommonProps, MarginProps {
    children: React$1.ReactNode;
}
declare type ValidationMessageProps = PropsWithHTMLElement<ValidationMessageInternalProps, 'div'>;
declare const ValidationMessage: React$1.ForwardRefExoticComponent<Omit<Omit<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React$1.HTMLAttributes<HTMLDivElement>>, never>, keyof ValidationMessageInternalProps> & ValidationMessageInternalProps & React$1.RefAttributes<HTMLDivElement>>;

interface BaseInputInternalProps extends CommonProps {
    /**
     * Sets the id of the input
     */
    id?: string;
    /**
     * Allows to render input | textarea tag
     */
    as?: 'input' | 'textarea';
    /**
     * Set the value of the input
     */
    value?: string;
    /**
     * Set the name of the input
     */
    name?: string;
    /**
     * Applies disabled styles
     * @default false
     */
    isDisabled?: boolean;
    /**
     * Applies read-only styles
     * @default false
     */
    isReadOnly?: boolean;
    /**
     * Applies invalid styles
     * @default false
     */
    isInvalid?: boolean;
    /**
     * Validate the input
     * @default false
     */
    isRequired?: boolean;
    /**
     * Boolean property that allows to blur on escape
     * @default true
     */
    willBlurOnEsc?: boolean;
    /**
     * Expects any of the icon components
     */
    icon?: React.ReactElement;
    /**
     * Allows to listen to an inputâ€™s change in value
     */
    onChange?: ChangeEventHandler<HTMLTextAreaElement | HTMLInputElement>;
    /**
     * Allows to listen to an event when a key is pressed
     */
    onKeyDown?: KeyboardEventHandler<HTMLTextAreaElement | HTMLInputElement>;
    /**
     * Allows to listen to an event when an element loses focus
     */
    onBlur?: FocusEventHandler<HTMLTextAreaElement | HTMLInputElement>;
    /**
     * Allows to listen to an event when an element get focused
     */
    onFocus?: FocusEventHandler<HTMLTextAreaElement | HTMLInputElement>;
    /**
     * Defines which size of the input should be rendered
     * @default medium
     */
    size?: 'small' | 'medium';
    /**
     * Sets whether an element is resizable, and if so, in which directions
     * @default vertical
     */
    resize?: 'none' | 'both' | 'horizontal' | 'vertical';
}

declare type checkboxTypes = 'checkbox' | 'radio' | 'switch';
interface BaseCheckboxInternalProps extends Omit<BaseInputInternalProps, 'type' | 'as' | 'placeholder' | 'isReadOnly' | 'icon' | 'label'> {
    /**
     * Defines the type of the input to be rendered
     * @default checkbox
     */
    type?: checkboxTypes;
    /**
     * Defines if the element is checked, onChange will be required
     * @default undefined
     */
    isChecked?: boolean;
    /**
     * Defines initial checked state for an uncontrolled component
     * @default false
     */
    defaultChecked?: boolean;
    /**
     * Defines if the state is indeterminate
     * @default false
     */
    isIndeterminate?: boolean;
    /**
     * Additional props that are passed to the input element
     */
    inputProps?: Partial<ComponentPropsWithoutRef<'input'>> & {
        'data-test-id'?: string;
    };
    /**
     * Value to be set as aria-label if not passing a children
     */
    'aria-label'?: string;
    /**
     * Size of the input, only valid for switch input
     * @default medium
     */
    size?: 'small' | 'medium';
    /**
     * Optional text to be added as help text bellow the label
     */
    helpText?: string;
    onChange?: ChangeEventHandler<HTMLInputElement>;
    density?: Density;
}

declare type BaseCheckboxProps = PropsWithHTMLElement<BaseCheckboxInternalProps, 'label', 'htmlFor'>;

declare type CheckboxProps = Omit<BaseCheckboxProps, 'type' | 'size'>;
declare const Checkbox$1: React$1.ForwardRefExoticComponent<CheckboxProps & React$1.RefAttributes<HTMLInputElement>>;

interface BaseCheckboxGroupProps extends CommonProps {
    /**
     * Handler that will be triggered when any checkbox inside the group loses focus
     */
    onBlur?: FocusEventHandler<HTMLInputElement>;
    /**
     * Handler that will be triggered when any checkbox inside the group has their checked state changed
     */
    onChange?: ChangeEventHandler<HTMLInputElement>;
    /**
     * Name that will be assigned to all checkboxes inside the group, unless a different name is passed to the checkbox
     */
    name?: string;
    /**
     * Elements that should be in the group
     */
    children: React$1.ReactNode;
    /**
     * Type of the inputs used within the group
     */
    type: 'checkbox' | 'radio';
    /**
     * Array of values for checkboxes or single value for radio, that should be checked for uncontrolled inputs
     */
    defaultValue?: Array<string> | string;
    /**
     * Array of values for checkboxes or single value for radio, that should be checked for controlled inputs
     */
    value?: Array<string> | string;
}

interface CheckboxGroupProps extends Omit<BaseCheckboxGroupProps, 'type'> {
    /**
     * Array of values of the checkboxes that should be checked for uncontrolled inputs
     */
    defaultValue?: Array<string>;
    /**
     * Array of values of the checkboxes that should be checked for controlled inputs
     */
    value?: Array<string>;
}
declare const CheckboxGroup: React$1.ForwardRefExoticComponent<CheckboxGroupProps & React$1.RefAttributes<HTMLDivElement>>;

declare type CompoundCheckbox = typeof Checkbox$1 & {
    Group: typeof CheckboxGroup;
};
declare const Checkbox: CompoundCheckbox;

interface FormControlContextProps {
    id?: string;
    /**
     * If `true` set the form control to the invalid state.
     */
    isInvalid?: boolean;
    /**
     * If `true` set the form control to be required.
     */
    isRequired?: boolean;
    /**
     * If `true` set the form control to the disabled state.
     */
    isDisabled?: boolean;
    /**
     * If `true` set the form control to the read only state.
     */
    isReadOnly?: boolean;
    /**
     * Max length of characters used for the text input and textarea
     */
    maxLength?: number;
    /**
     * value from text input and textarea to used for counting characters
     */
    inputValue?: string;
    /**
     * Set max length function
     */
    setMaxLength?: React.Dispatch<React.SetStateAction<number>>;
    /**
     * Set input value function
     */
    setInputValue?: React.Dispatch<React.SetStateAction<string>>;
}

declare const FORM_CONTROL_DEFAULT_TAG = "div";
interface FormControlInternalProps extends FormControlContextProps, CommonProps, MarginProps {
    as?: 'div' | 'fieldset';
    children: React$1.ReactNode;
}
declare type FormControlProps<E extends React$1.ElementType = typeof FORM_CONTROL_DEFAULT_TAG> = PolymorphicProps<FormControlInternalProps, E>;
declare const FormControl$1: PolymorphicComponent<ExpandProps<FormControlInternalProps>, typeof FORM_CONTROL_DEFAULT_TAG>;

interface FormLabelInternalProps extends CommonProps, MarginProps {
    /**
     * Label value to show
     */
    children: ReactNode;
    /**
     * Whether or not the associated input element is required
     *
     * @default false
     */
    isRequired?: boolean;
    /**
     * Custom text to show in parentheses that gets rendered if the associated
     * input is required
     *
     * @default "required"
     */
    requiredText?: string;
    /**
     * Defines how the element will be rendered
     * @default label
     */
    as?: 'label' | 'legend';
}
declare const FORM_LABEL_DEFAULT_TAG = "label";
declare type FormLabelProps<E extends React$1.ElementType = typeof FORM_LABEL_DEFAULT_TAG> = PolymorphicProps<FormLabelInternalProps, E>;
declare const FormLabel: PolymorphicComponent<ExpandProps<FormLabelInternalProps>, typeof FORM_LABEL_DEFAULT_TAG>;

declare type CounterProps = PropsWithHTMLElement<CommonProps, 'p'>;
declare const Counter: React$1.ForwardRefExoticComponent<Omit<Omit<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLParagraphElement>, HTMLParagraphElement>, "key" | keyof React$1.HTMLAttributes<HTMLParagraphElement>>, never>, keyof CommonProps> & CommonProps & React$1.RefAttributes<HTMLParagraphElement>>;

declare type CompoundFormControl = typeof FormControl$1 & {
    Label: typeof FormLabel;
    ValidationMessage: typeof ValidationMessage;
    HelpText: typeof HelpText;
    Counter: typeof Counter;
};
declare const FormControl: CompoundFormControl;

declare type RadioProps = Omit<BaseCheckboxProps, 'type' | 'isIndeterminate' | 'size'>;
declare const Radio$1: React$1.ForwardRefExoticComponent<RadioProps & React$1.RefAttributes<HTMLInputElement>>;

interface RadioGroupProps extends Omit<BaseCheckboxGroupProps, 'type'> {
    /**
     * Value of the radio that should be checked for uncontrolled inputs
     */
    defaultValue?: string;
    /**
     * Value of the radio that should be checked for controlled inputs
     */
    value?: string;
}
declare const RadioGroup: React$1.ForwardRefExoticComponent<RadioGroupProps & React$1.RefAttributes<HTMLDivElement>>;

declare type CompoundRadio = typeof Radio$1 & {
    Group: typeof RadioGroup;
};
declare const Radio: CompoundRadio;

declare const INPUT_DEFAULT_TAG = "input";
declare type BaseInputProps<E extends React$1.ElementType = typeof INPUT_DEFAULT_TAG> = PolymorphicProps<BaseInputInternalProps, E, 'disabled' | 'required' | 'readOnly'>;

interface TextInputProps extends Omit<BaseInputProps, 'as' | 'onCopy' | 'resize'> {
    /**
     * Set's default value for text input
     */
    defaultValue?: string;
}

declare const TextInput$1: React$1.ForwardRefExoticComponent<TextInputProps & React$1.RefAttributes<HTMLInputElement>>;

declare type InputGroupSpacing = SpacingTokens | 'none';

interface InputGroupProps extends CommonProps {
    /**
     * Sets the spacing of the elements if variant is separate.
     * @default spacingS
     */
    spacing?: InputGroupSpacing;
    children: React$1.ReactNode;
}
declare const InputGroup: React$1.ForwardRefExoticComponent<InputGroupProps & React$1.RefAttributes<HTMLDivElement>>;

declare type CompoundTextInput = typeof TextInput$1 & {
    Group: typeof InputGroup;
};
declare const TextInput: CompoundTextInput;

declare type SwitchProps = Omit<BaseCheckboxProps, 'type' | 'isIndeterminate'>;
declare const Switch: React$1.ForwardRefExoticComponent<SwitchProps & React$1.RefAttributes<HTMLInputElement>>;

interface TextareaProps extends Omit<BaseInputProps<'textarea'>, 'as' | 'type' | 'size'> {
    /**
     * Set's default value for textarea
     */
    defaultValue?: string;
}
/**
 * Textarea is a form component that allows the user to enter a sizeable amount of multi-line plain text.
 */
declare const Textarea: React$1.ForwardRefExoticComponent<TextareaProps & React$1.RefAttributes<HTMLTextAreaElement>>;

declare type OptionInternalProps = CommonProps & {
    isDisabled?: boolean;
};
declare type OptionProps = PropsWithHTMLElement<OptionInternalProps, 'option', 'defaultChecked' | 'defaultValue' | 'selected' | 'disabled'>;
declare const Option: ({ testId, isDisabled, ...otherProps }: OptionProps) => JSX.Element;

declare type SelectSize = 'small' | 'medium';
declare type SelectInternalProps = CommonProps & {
    isRequired?: boolean;
    isInvalid?: boolean;
    isDisabled?: boolean;
    onChange?: ChangeEventHandler<HTMLSelectElement>;
    children: ReactNode;
    willBlurOnEsc?: boolean;
    size?: SelectSize;
    value?: string;
    defaultValue?: string;
};
declare type SelectProps = PropsWithHTMLElement<SelectInternalProps, 'select', 'disabled' | 'required'>;
declare const Select$1: React$1.ForwardRefExoticComponent<Omit<Omit<Pick<React$1.DetailedHTMLProps<React$1.SelectHTMLAttributes<HTMLSelectElement>, HTMLSelectElement>, "key" | keyof React$1.SelectHTMLAttributes<HTMLSelectElement>>, "disabled" | "required">, "value" | "children" | "isInvalid" | "isRequired" | "isDisabled" | "defaultValue" | "onChange" | "size" | keyof CommonProps | "willBlurOnEsc"> & CommonProps & {
    isRequired?: boolean;
    isInvalid?: boolean;
    isDisabled?: boolean;
    onChange?: ChangeEventHandler<HTMLSelectElement>;
    children: ReactNode;
    willBlurOnEsc?: boolean;
    size?: SelectSize;
    value?: string;
    defaultValue?: string;
} & React$1.RefAttributes<HTMLSelectElement>>;

declare type CompoundSelect = typeof Select$1 & {
    Option: typeof Option;
};
declare const Select: CompoundSelect;

declare type FormProps = PropsWithHTMLElement<CommonProps, 'form'>;
declare const Form: React$1.ForwardRefExoticComponent<Omit<Omit<Pick<React$1.DetailedHTMLProps<React$1.FormHTMLAttributes<HTMLFormElement>, HTMLFormElement>, "key" | keyof React$1.FormHTMLAttributes<HTMLFormElement>>, never>, keyof CommonProps> & CommonProps & React$1.RefAttributes<HTMLFormElement>>;

export { Checkbox, CheckboxGroupProps, CheckboxProps, Counter, CounterProps, Form, FormControl, FormControlInternalProps, FormControlProps, FormLabel, FormLabelInternalProps, FormLabelProps, FormProps, HelpText, HelpTextProps, InputGroupProps, Option, OptionProps, Radio, RadioGroupProps, RadioProps, Select, SelectInternalProps, SelectProps, Switch, SwitchProps, TextInput, TextInputProps, Textarea, TextareaProps, ValidationMessage, ValidationMessageProps };
