function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/* eslint-disable @typescript-eslint/no-explicit-any */
import { sleep } from './utils';
const DEFAULT_MAX_RETRIES = 30;
const DEFAULT_INITIAL_DELAY_MS = 1000;
const DEFAULT_RETRY_INTERVAL_MS = 2000;

/** Action is an interface that has a sys.status to be checked against */

export class AsyncActionProcessingError extends Error {
  constructor(message, action) {
    super(message);
    _defineProperty(this, "action", void 0);
    this.action = action;
    this.name = this.constructor.name;
  }
}
export class AsyncActionFailedError extends AsyncActionProcessingError {}
/**
 * @description Waits for an Action to be completed and to be in one of the final states (failed or succeeded)
 * @param {Function} actionFunction - GET function that will be called every interval to fetch an Action status
 * @throws {ActionFailedError} throws an error if `throwOnFailedExecution = true` with the Action that failed.
 * @throws {AsyncActionProcessingError} throws an error with a Action when processing takes too long.
 */
export async function pollAsyncActionStatus(actionFunction, options) {
  var _options$retryCount, _options$retryInterva, _options$initialDelay, _options$throwOnFaile, _action;
  let retryCount = 0;
  let done = false;
  let action;
  const maxRetries = (_options$retryCount = options === null || options === void 0 ? void 0 : options.retryCount) !== null && _options$retryCount !== void 0 ? _options$retryCount : DEFAULT_MAX_RETRIES;
  const retryIntervalMs = (_options$retryInterva = options === null || options === void 0 ? void 0 : options.retryIntervalMs) !== null && _options$retryInterva !== void 0 ? _options$retryInterva : DEFAULT_RETRY_INTERVAL_MS;
  const initialDelayMs = (_options$initialDelay = options === null || options === void 0 ? void 0 : options.initialDelayMs) !== null && _options$initialDelay !== void 0 ? _options$initialDelay : DEFAULT_INITIAL_DELAY_MS;
  const throwOnFailedExecution = (_options$throwOnFaile = options === null || options === void 0 ? void 0 : options.throwOnFailedExecution) !== null && _options$throwOnFaile !== void 0 ? _options$throwOnFaile : true;

  // Initial delay for short-running Actions
  await sleep(initialDelayMs);
  while (retryCount < maxRetries && !done) {
    action = await actionFunction();

    // Terminal states
    if (action && ['succeeded', 'failed'].includes(action.sys.status)) {
      done = true;
      if (action.sys.status === 'failed' && throwOnFailedExecution) {
        throw new AsyncActionFailedError(`${action.sys.type} failed to execute.`, action);
      }
      return action;
    }
    await sleep(retryIntervalMs);
    retryCount += 1;
  }
  throw new AsyncActionProcessingError(`${(_action = action) === null || _action === void 0 ? void 0 : _action.sys.type} didn't finish processing within the expected timeframe.`, action);
}