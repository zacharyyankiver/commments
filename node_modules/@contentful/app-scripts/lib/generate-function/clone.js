"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneFunction = cloneFunction;
exports.getCloneURL = getCloneURL;
exports.touchupAppManifest = touchupAppManifest;
exports.moveFilesToFinalDirectory = moveFilesToFinalDirectory;
exports.renameClonedFiles = renameClonedFiles;
exports.resolvePaths = resolvePaths;
exports.cloneAndResolveManifests = cloneAndResolveManifests;
exports.clone = clone;
exports.mergeAppManifest = mergeAppManifest;
exports.updatePackageJsonWithBuild = updatePackageJsonWithBuild;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const tiged = require('tiged');
const node_fs_1 = __importDefault(require("node:fs"));
const chalk_1 = __importDefault(require("chalk"));
const node_path_1 = require("node:path");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const file_1 = require("./utils/file");
const package_1 = require("./utils/package");
const addBuildCommand = (0, package_1.getAddBuildCommandFn)({
    name: 'build:functions',
    command: 'contentful-app-scripts build-functions --ci',
});
async function cloneFunction(localPath, settings) {
    try {
        console.log((0, logger_1.highlight)(`---- Cloning function ${chalk_1.default.cyan(settings.name)}...`));
        const { localTmpPath, localFunctionsPath } = resolvePaths(localPath);
        const cloneURL = getCloneURL(settings);
        // Pass keepPackageJson if available in settings (from GenerateFunctionSettingsCLI)
        const keepPackageJson = 'keepPackageJson' in settings && typeof settings.keepPackageJson === 'boolean' ? settings.keepPackageJson : false;
        await cloneAndResolveManifests(cloneURL, localTmpPath, localPath, localFunctionsPath, keepPackageJson);
        // now rename the function file. Find the file with a .ts or .js extension
        const renameFunctionFile = renameClonedFiles(localTmpPath, settings);
        // copy the cloned files to the functions directory
        moveFilesToFinalDirectory(localTmpPath, localFunctionsPath, localPath);
        // now alter the app-manifest.json to point to the new function file
        await touchupAppManifest(localPath, settings, renameFunctionFile);
    }
    catch (e) {
        (0, logger_1.error)(`Failed to clone function ${(0, logger_1.highlight)(chalk_1.default.cyan(settings.name))}`, e);
        throw Error(chalk_1.default.red('Failed to clone function ') + (0, logger_1.highlight)(chalk_1.default.cyan(settings.name)));
    }
}
function getCloneURL(settings) {
    return `${constants_1.REPO_URL}/${settings.example}/${settings.language}`;
}
async function touchupAppManifest(localPath, settings, renameFunctionFile) {
    const appManifestPath = (0, node_path_1.resolve)(localPath, constants_1.CONTENTFUL_APP_MANIFEST);
    const appManifest = JSON.parse(node_fs_1.default.readFileSync(appManifestPath, 'utf-8'));
    const entry = appManifest["functions"][appManifest["functions"].length - 1];
    entry.id = settings.name;
    // the path always has a .js extension
    // and path and entryFile are always POSIX style paths
    entry.path = `functions/${renameFunctionFile.replace('.ts', '.js')}`;
    entry.entryFile = `functions/${renameFunctionFile}`;
    await node_fs_1.default.writeFileSync(appManifestPath, JSON.stringify(appManifest, null, 2));
}
function moveFilesToFinalDirectory(localTmpPath, localFunctionsPath, localPath) {
    // Create functions directory if it doesn't exist
    if (!node_fs_1.default.existsSync(localFunctionsPath)) {
        node_fs_1.default.mkdirSync(localFunctionsPath, { recursive: true });
    }
    // Get all files from tmp directory
    const files = node_fs_1.default.readdirSync(localTmpPath);
    // Copy each file except package.json, if it exists
    for (const file of files) {
        const sourcePath = (0, node_path_1.resolve)(localTmpPath, file);
        if (file === 'package.json') {
            const destPath = (0, node_path_1.resolve)(localPath, 'package.json');
            node_fs_1.default.cpSync(sourcePath, destPath);
            continue;
        }
        const destPath = (0, node_path_1.resolve)(localFunctionsPath, file);
        node_fs_1.default.cpSync(sourcePath, destPath, { recursive: true });
    }
    // Clean up tmp directory
    node_fs_1.default.rmSync(localTmpPath, { recursive: true, force: true });
}
function renameClonedFiles(localTmpPath, settings) {
    const files = node_fs_1.default.readdirSync(localTmpPath);
    const functionFile = files.find((file) => file.endsWith('.ts') || file.endsWith('.js'));
    if (!functionFile) {
        throw new Error(`No function file found in ${localTmpPath}`);
    }
    const newFunctionFile = `${settings.name}.${settings.language === 'typescript' ? 'ts' : 'js'}`;
    node_fs_1.default.renameSync((0, node_path_1.resolve)(localTmpPath, functionFile), (0, node_path_1.resolve)(localTmpPath, newFunctionFile));
    return newFunctionFile;
}
function resolvePaths(localPath) {
    const localTmpPath = (0, node_path_1.resolve)(localPath, 'tmp'); // we require a tmp directory because tiged overwrites all files in the target directory
    const localFunctionsPath = (0, node_path_1.resolve)(localPath, 'functions');
    return { localTmpPath, localFunctionsPath };
}
async function cloneAndResolveManifests(cloneURL, localTmpPath, localPath, localFunctionsPath, keepPackageJson = false) {
    const tigedInstance = await clone(cloneURL, localTmpPath);
    // merge the manifest from the template folder to the root folder
    await mergeAppManifest(localPath, localTmpPath);
    // create a deep copy of the IGNORED_CLONED_FILES array
    const ignoredFiles = Array.from(constants_1.IGNORED_CLONED_FILES);
    if (!keepPackageJson) {
        // modify package.json build commands
        await updatePackageJsonWithBuild(localPath, localTmpPath);
        ignoredFiles.push('package.json');
    }
    // check if a tsconfig.json file exists already
    const tsconfigExists = await (0, file_1.exists)((0, node_path_1.resolve)(localFunctionsPath, 'tsconfig.json'));
    if (tsconfigExists) {
        ignoredFiles.push('tsconfig.json');
    }
    // remove the cloned files that we've already merged
    await tigedInstance.remove("unused_param", localTmpPath, {
        action: 'remove',
        files: ignoredFiles.map((fileName) => `${localTmpPath}/${fileName}`),
    });
}
async function clone(cloneURL, localFunctionsPath) {
    const tigedInstance = tiged(cloneURL, { mode: 'tar', disableCache: true, force: true });
    await tigedInstance.clone(localFunctionsPath);
    return tigedInstance;
}
async function mergeAppManifest(localPath, localTmpPath) {
    const finalAppManifestType = await (0, file_1.exists)((0, node_path_1.resolve)(localPath, constants_1.CONTENTFUL_APP_MANIFEST));
    const tmpAppManifestType = await (0, file_1.whichExists)(localTmpPath, [constants_1.CONTENTFUL_APP_MANIFEST, constants_1.APP_MANIFEST]); // find the app manifest in the cloned files
    if (!finalAppManifestType) {
        await (0, file_1.mergeJsonIntoFile)({
            source: (0, node_path_1.resolve)(localTmpPath, tmpAppManifestType),
            destination: (0, node_path_1.resolve)(localPath, constants_1.CONTENTFUL_APP_MANIFEST), // always save as contentful-app-manifest.json
        });
    }
    else {
        // add the function to the json's "functions" array
        await (0, file_1.mergeJsonIntoFile)({
            source: (0, node_path_1.resolve)(localTmpPath, tmpAppManifestType),
            destination: (0, node_path_1.resolve)(localPath, constants_1.CONTENTFUL_APP_MANIFEST),
            mergeFn: (destinationJson = {}, sourceJson = {}) => {
                if (!destinationJson.functions) {
                    destinationJson.functions = [];
                }
                if (sourceJson.functions && sourceJson.functions.length > 0) {
                    destinationJson.functions.push(sourceJson.functions[0]);
                }
                return destinationJson;
            },
        });
    }
}
async function updatePackageJsonWithBuild(localPath, localTmpPath) {
    const packageJsonLocation = (0, node_path_1.resolve)(localPath, 'package.json');
    const packageJsonExists = await (0, file_1.exists)(packageJsonLocation);
    if (packageJsonExists) {
        await (0, file_1.mergeJsonIntoFile)({
            source: (0, node_path_1.resolve)(localTmpPath, 'package.json'),
            destination: packageJsonLocation,
            mergeFn: addBuildCommand,
        });
    }
    else {
        (0, logger_1.warn)(`Failed to add function build commands: ${packageJsonLocation} does not exist.`);
    }
}
