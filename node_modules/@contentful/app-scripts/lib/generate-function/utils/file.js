"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJsonData = getJsonData;
exports.mergeJsonIntoFile = mergeJsonIntoFile;
exports.exists = exists;
exports.whichExists = whichExists;
const merge_options_1 = __importDefault(require("merge-options"));
const promises_1 = require("fs/promises");
const node_path_1 = require("node:path");
async function getJsonData(path) {
    if (!path) {
        return undefined;
    }
    const normalizedPath = (0, node_path_1.resolve)(path);
    if (!(await exists(normalizedPath))) {
        return undefined;
    }
    return JSON.parse(await (0, promises_1.readFile)(normalizedPath, { encoding: 'utf-8' }));
}
async function mergeJsonIntoFile({ source, destination, mergeFn = merge_options_1.default.bind({ concatArrays: false }), }) {
    const sourceJson = await getJsonData(source);
    const destinationJson = await getJsonData(destination);
    const mergedJson = mergeFn(destinationJson, sourceJson);
    await (0, promises_1.writeFile)((0, node_path_1.resolve)(destination), JSON.stringify(mergedJson, null, '  '));
}
function exists(path) {
    return (0, promises_1.access)(path)
        .then(() => true)
        .catch(() => false);
}
/**
 * Check a directory if two files exist, returning the first one that exists or "None"
 * @param basePath Base path
 * @param paths List of paths, in order of preference
 * @returns First subpath if it exists, otherwise the second if it exists, otherwise "None"
 */
async function whichExists(basePath, paths) {
    for (const path of paths) {
        try {
            await (0, promises_1.access)((0, node_path_1.join)(basePath, path));
            return path;
        }
        catch (error) {
            // Ignore and continue checking the next path
        }
    }
    return "None";
}
