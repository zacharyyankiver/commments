{"version":3,"sources":["../src/Autocomplete.tsx","../src/AutocompleteItems.tsx","../src/Autocomplete.styles.ts"],"names":["React","useCallback","useState","cx","useCombobox","mergeRefs","IconButton","TextInput","CloseIcon","ChevronDownIcon","Skeleton","Popover","Subheading","SectionHeading","getStringMatch","Text","css","tokens","getMenuItemStyles","getAutocompleteStyles","listMaxHeight","isActive","isDisabled","AutocompleteItems","props","items","elementStartIndex","highlightedIndex","getItemProps","renderItem","inputValue","styles","item","index","itemIndex","itemProps","__spreadProps","__spreadValues","HighlightedItem","before","match","after","_Autocomplete","ref","isOpenProp","onClose","onOpen","id","className","clearAfterSelect","textOnAfterSelect","closeAfterSelect","defaultValue","selectedItem","inputValueProp","onInputValueChange","onSelectItem","onFocus","onBlur","icon","itemToString","isInvalid","isRequired","isReadOnly","showEmptyList","noMatchesMessage","placeholder","inputRef","toggleRef","listRef","listWidth","isGrouped","isLoading","usePortal","testId","popoverTestId","showClearButtonProp","aria","_inputValue","setInputValue","handleInputValueChange","value","handleNativeChangeEvent","event","flattenItems","isUsingGroups","acc","group","isShowingNoMatches","getComboboxProps","getInputProps","getMenuProps","getToggleButtonProps","isOpen","openMenu","toggleMenu","state","type","changes","_a","_labelledby","_inputId","inputProps","__objRest","comboboxProps","toggleProps","menuProps","showClearButton","_","ListItemLoadingState","render","Autocomplete"],"mappings":"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","sourcesContent":["import React, { useCallback, useState } from 'react';\nimport { cx } from 'emotion';\nimport { useCombobox } from 'downshift';\n\nimport {\n  mergeRefs,\n  type CommonProps,\n  type ExpandProps,\n} from '@contentful/f36-core';\nimport { IconButton } from '@contentful/f36-button';\nimport { TextInput, type TextInputProps } from '@contentful/f36-forms';\nimport { CloseIcon, ChevronDownIcon } from '@contentful/f36-icons';\nimport { Skeleton } from '@contentful/f36-skeleton';\nimport { Popover } from '@contentful/f36-popover';\nimport { Subheading, SectionHeading } from '@contentful/f36-typography';\n\nimport { AutocompleteItems } from './AutocompleteItems';\nimport { getAutocompleteStyles } from './Autocomplete.styles';\n\nexport interface GenericGroupType<ItemType> {\n  groupTitle: string;\n  options: ItemType[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface AutocompleteProps<ItemType>\n  extends CommonProps,\n    Pick<\n      TextInputProps,\n      | 'isDisabled'\n      | 'isInvalid'\n      | 'isReadOnly'\n      | 'isRequired'\n      | 'id'\n      | 'defaultValue'\n    > {\n  /**\n   * Itâ€™s an array of data to be used as \"options\" by the autocomplete component.\n   * This can either be a plain list of items or a list of groups of items.\n   */\n  items: ItemType[] | GenericGroupType<ItemType>[];\n\n  /**\n   * Boolean to control whether the Autocomplete menu is open\n   */\n  isOpen?: boolean;\n\n  /**\n   * Callback fired when the Autocomplete menu opens\n   */\n  onOpen?: () => void;\n\n  /**\n   * Callback fired when the Autocomplete menu closes\n   */\n  onClose?: () => void;\n\n  /**\n   * Set a custom icon for the text input\n   */\n  icon?: React.ReactElement;\n\n  /**\n   * Tells if the item is a object with groups\n   */\n  isGrouped?: boolean;\n\n  /**\n   * Set the value of the text input\n   */\n  inputValue?: string;\n  /**\n   * Function called whenever the input value changes\n   */\n  onInputValueChange?: (value: string) => void;\n  /**\n   * This is the function that will be called when the user selects one of the \"options\" in the list.\n   * The component will pass the selected \"item\" as an argument to the function..\n   */\n  onSelectItem: (item: ItemType) => void;\n\n  /**\n   * Applying the selectedItem property turns autocomplete into a controlled component.\n   * Can be used to display e.g. previously selected element. If it is an object the itemToString function will apply to it.\n   */\n  selectedItem?: ItemType;\n\n  /**\n   * This is the function that will be called for each \"item\" passed in the `items` prop.\n   * It receives the \"item\" and \"inputValue\" as arguments and returns a ReactNode.\n   * The inputValue is passed in case you want to highlight the match on the render.\n   */\n  renderItem?: (item: ItemType, inputValue: string) => React.ReactNode;\n  /**\n   * When using objects as `items`, we recommend passing a function that tells Downshift how to extract a string\n   * from those objetcs to be used as inputValue\n   */\n  itemToString?: (item: ItemType) => string;\n  /**\n   * Text input behaviour after an item is selected\n   * @default \"replace\"\n   */\n  textOnAfterSelect?: 'clear' | 'preserve' | 'replace';\n  /**\n   * If this is set to `true` the text input will be cleared after an item is selected\n   * @default false\n   * @deprecated Use textOnAfterSelect=\"clear\" instead\n   */\n  clearAfterSelect?: boolean;\n  /**\n   * If this is set to `false` the dropdown menu will stay open after selecting an item\n   * @default true\n   */\n  closeAfterSelect?: boolean;\n  /**\n   * This is the value will be passed to the `placeholder` prop of the input.\n   * @default \"Search\"\n   */\n  placeholder?: string;\n  /**\n   * Defines if the list should be shown even if empty, when input is focused\n   * @default false\n   */\n  showEmptyList?: boolean;\n  /**\n   * A message that will be shown when it is not possible to find any option that matches the input value\n   * @default \"No matches\"\n   */\n  noMatchesMessage?: string;\n  /**\n   * Use this prop to get a ref to the input element of the component\n   */\n  inputRef?: React.Ref<HTMLInputElement>;\n  /**\n   * Use this prop to get a ref to the toggle button of the component\n   */\n  toggleRef?: React.Ref<HTMLButtonElement>;\n  /**\n   * Use this prop to get a ref to the list of items of the component\n   */\n  listRef?: React.Ref<HTMLUListElement>;\n  /**\n   * It sets the width of the list\n   * @default \"auto\"\n   */\n  listWidth?: 'auto' | 'full';\n  /**\n   * It sets the max-height, in pixels, of the list\n   * The default value is the height of 5 single line items\n   * @default 180\n   */\n  listMaxHeight?: number;\n  /**\n   * Sets the list to show its loading state\n   * @default false\n   */\n  isLoading?: boolean;\n  /**\n   * Boolean to control whether or not to render the suggestions box in a React Portal.\n   * Rendering content inside a Portal allows the suggestions box to escape the bounds\n   * of its parent while still being positioned correctly.\n   * Defaults to `false`\n   */\n  usePortal?: boolean;\n\n  /**\n   * A [data-test-id] attribute for the suggestions box used for testing purposes\n   */\n  popoverTestId?: string;\n\n  /**\n   * Function called when the input is focused\n   *\n   * @param event\n   */\n  onFocus?: (event: React.FocusEvent<HTMLInputElement>) => void;\n  /**\n   * Function called when the input is blurred\n   * @param event\n   */\n  onBlur?: (event: React.FocusEvent<HTMLInputElement>) => void;\n  /**\n   * Manually control when the button to clear the input value is shown\n   */\n  showClearButton?: boolean;\n  /**\n   * Additional aria attributes\n   */\n  aria?: {\n    showListIconLabel?: string;\n    clearSelectionIconLabel?: string;\n  };\n}\n\nfunction _Autocomplete<ItemType>(\n  props: AutocompleteProps<ItemType>,\n  ref: React.Ref<HTMLDivElement>,\n) {\n  const {\n    isOpen: isOpenProp,\n    onClose,\n    onOpen,\n    id,\n    className,\n    clearAfterSelect = false,\n    textOnAfterSelect = clearAfterSelect ? 'clear' : 'replace',\n    closeAfterSelect = true,\n    defaultValue = '',\n    selectedItem,\n    items,\n    inputValue: inputValueProp,\n    onInputValueChange,\n    onSelectItem,\n    onFocus,\n    onBlur,\n    renderItem,\n    icon = <ChevronDownIcon variant=\"muted\" />,\n    itemToString = (item: ItemType) => item as unknown as string,\n    isInvalid,\n    isDisabled,\n    isRequired,\n    isReadOnly,\n    showEmptyList,\n    noMatchesMessage = 'No matches found',\n    placeholder = 'Search',\n    inputRef,\n    toggleRef,\n    listRef,\n    listWidth = 'auto',\n    listMaxHeight = 180,\n    isGrouped = false,\n    isLoading = false,\n    usePortal = false,\n    testId = 'cf-autocomplete',\n    popoverTestId = 'cf-autocomplete-container',\n    showClearButton: showClearButtonProp,\n    aria = {\n      clearSelectionIconLabel: 'Clear',\n      showListIconLabel: 'Show list',\n    },\n  } = props;\n\n  type GroupType = GenericGroupType<ItemType>;\n\n  const styles = getAutocompleteStyles(listMaxHeight);\n\n  const [_inputValue, setInputValue] = useState(defaultValue);\n  const inputValue =\n    typeof inputValueProp === 'undefined' ? _inputValue : inputValueProp;\n\n  const handleInputValueChange = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      onInputValueChange?.(value);\n    },\n    [onInputValueChange],\n  );\n\n  // Handle manually to avoid a jumping cursor, see https://github.com/downshift-js/downshift/issues/1108#issuecomment-842407759\n  const handleNativeChangeEvent = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n      const value = event.target.value;\n      handleInputValueChange(value);\n    },\n    [handleInputValueChange],\n  );\n\n  const flattenItems = isUsingGroups(isGrouped, items)\n    ? items.reduce(\n        (acc: ItemType[], group: GroupType) => [...acc, ...group.options],\n        [],\n      )\n    : items;\n\n  const isShowingNoMatches = isUsingGroups(isGrouped, items)\n    ? items.every((group: GroupType) => group.options.length === 0)\n    : items.length === 0;\n\n  const {\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getMenuProps,\n    getToggleButtonProps,\n    highlightedIndex,\n    isOpen,\n    openMenu,\n    toggleMenu,\n  } = useCombobox({\n    isOpen: isOpenProp,\n    onIsOpenChange: ({ isOpen }) => {\n      if (isOpen) {\n        onOpen?.();\n      } else {\n        onClose?.();\n      }\n    },\n    stateReducer: (state, { type, changes }) => {\n      switch (type) {\n        case useCombobox.stateChangeTypes.InputBlur: {\n          // don't change input value on blur\n          return { ...changes, inputValue: state.inputValue };\n        }\n\n        // item is selected by click or keydown\n        case useCombobox.stateChangeTypes.InputKeyDownEnter:\n        case useCombobox.stateChangeTypes.ItemClick: {\n          // prevent the menu from being closed when the user selects an item with a keyboard or mouse\n          if (!closeAfterSelect) {\n            return {\n              ...changes,\n              isOpen: state.isOpen,\n            };\n          }\n\n          return changes;\n        }\n        default:\n          return changes;\n      }\n    },\n    items: flattenItems,\n    selectedItem,\n    inputValue,\n    itemToString,\n    onInputValueChange: ({ type, inputValue }) => {\n      switch (type) {\n        // value is set directly from the TextInput onChange handler\n        case useCombobox.stateChangeTypes.InputChange: {\n          return;\n        }\n\n        // item is selected by click or keydown\n        case useCombobox.stateChangeTypes.ItemClick:\n        case useCombobox.stateChangeTypes.InputKeyDownEnter: {\n          // clear the TextInput value\n          if (textOnAfterSelect === 'clear') {\n            handleInputValueChange('');\n            return;\n          }\n\n          // keep the current TextInput value\n          if (textOnAfterSelect === 'preserve') {\n            return;\n          }\n        }\n      }\n\n      handleInputValueChange(inputValue);\n    },\n    onStateChange: ({ type, selectedItem }) => {\n      switch (type) {\n        case useCombobox.stateChangeTypes.InputKeyDownEnter:\n        case useCombobox.stateChangeTypes.ItemClick:\n          if (selectedItem) {\n            onSelectItem(selectedItem);\n          }\n          break;\n        default:\n          break;\n      }\n    },\n  });\n\n  const {\n    'aria-labelledby': _labelledby,\n    id: _inputId,\n    ...inputProps\n  } = getInputProps();\n  const comboboxProps = getComboboxProps();\n  const toggleProps = getToggleButtonProps();\n  const menuProps = getMenuProps();\n  let elementStartIndex = 0;\n\n  const showClearButton = showClearButtonProp ?? inputValue;\n\n  return (\n    <div\n      data-test-id={testId}\n      className={cx(styles.autocomplete, className)}\n      ref={ref}\n    >\n      <Popover\n        usePortal={usePortal}\n        isOpen={isOpen}\n        isFullWidth={listWidth === 'full'}\n        renderOnlyWhenOpen={false}\n        // This is necessary, otherwise the focus will change from the input to the Popover\n        // and the user won't be able to type in the input\n        // eslint-disable-next-line jsx-a11y/no-autofocus\n        autoFocus={false}\n        id={menuProps.id}\n      >\n        <Popover.Trigger>\n          <div {...comboboxProps} className={styles.combobox}>\n            <TextInput\n              className={styles.inputField}\n              {...inputProps}\n              onFocus={(e) => {\n                onFocus?.(e as React.FocusEvent<HTMLInputElement>);\n                openMenu();\n              }}\n              onBlur={(e) => {\n                onBlur?.(e as React.FocusEvent<HTMLInputElement>);\n                inputProps.onBlur(e);\n              }}\n              id={id}\n              isInvalid={isInvalid}\n              isDisabled={isDisabled}\n              isRequired={isRequired}\n              isReadOnly={isReadOnly}\n              ref={mergeRefs(inputProps.ref, inputRef)}\n              testId=\"cf-autocomplete-input\"\n              placeholder={placeholder}\n              onChange={(event) => {\n                inputProps.onChange(event);\n                handleNativeChangeEvent(event);\n              }}\n            />\n            <IconButton\n              {...toggleProps}\n              ref={mergeRefs(toggleProps.ref, toggleRef)}\n              aria-label={\n                showClearButton\n                  ? aria.clearSelectionIconLabel\n                  : aria.showListIconLabel\n              }\n              className={styles.toggleButton}\n              variant=\"transparent\"\n              icon={showClearButton ? <CloseIcon variant=\"muted\" /> : icon}\n              onClick={() => {\n                if (showClearButton) {\n                  handleInputValueChange('');\n                } else {\n                  toggleMenu();\n                }\n              }}\n              isDisabled={isDisabled}\n              size=\"small\"\n            />\n          </div>\n        </Popover.Trigger>\n\n        {items.length > 0 || inputValue.length > 0 || showEmptyList ? (\n          <Popover.Content\n            {...menuProps}\n            ref={mergeRefs(menuProps.ref, listRef)}\n            className={styles.content}\n            testId={popoverTestId}\n          >\n            {isLoading &&\n              [...Array(3)].map((_, index) => (\n                <div\n                  key={index}\n                  className={cx(styles.item({ isDisabled: true }))}\n                >\n                  <ListItemLoadingState />\n                </div>\n              ))}\n\n            {!isLoading && isShowingNoMatches && (\n              <div className={styles.item({})}>\n                <Subheading className={styles.noMatchesTitle}>\n                  {noMatchesMessage}\n                </Subheading>\n              </div>\n            )}\n\n            {!isLoading &&\n              isUsingGroups(isGrouped, items) &&\n              items.map((group: GroupType, index: number) => {\n                if (group.options.length < 1) {\n                  return;\n                }\n                const render = (\n                  <div key={index}>\n                    <SectionHeading\n                      key={index}\n                      data-test-id=\"cf-autocomplete-grouptitle\"\n                      marginBottom=\"none\"\n                      className={styles.groupTitle}\n                    >\n                      {group.groupTitle}\n                    </SectionHeading>\n                    <AutocompleteItems<ItemType>\n                      items={group.options}\n                      highlightedIndex={highlightedIndex}\n                      getItemProps={getItemProps}\n                      renderItem={renderItem}\n                      inputValue={inputValue}\n                      elementStartIndex={elementStartIndex}\n                    />\n                  </div>\n                );\n                elementStartIndex += group.options.length;\n                return render;\n              })}\n\n            {!isLoading &&\n              !isUsingGroups(isGrouped, items) &&\n              items.length > 0 && (\n                <AutocompleteItems<ItemType>\n                  items={items}\n                  elementStartIndex={elementStartIndex}\n                  highlightedIndex={highlightedIndex}\n                  getItemProps={getItemProps}\n                  renderItem={renderItem}\n                  inputValue={inputValue}\n                />\n              )}\n          </Popover.Content>\n        ) : (\n          // We need to render an empty hidden div, so we can pass the menuProps or downshift will show a warning about it\n          // https://github.com/downshift-js/downshift/issues/1167#issuecomment-1088022842\n          <div {...menuProps} className={cx(styles.hidden)} />\n        )}\n      </Popover>\n    </div>\n  );\n}\n\nconst ListItemLoadingState = () => {\n  return (\n    <Skeleton.Container svgHeight={16}>\n      <Skeleton.BodyText numberOfLines={1} />\n    </Skeleton.Container>\n  );\n};\n\n// This is required to infer correct typings when differentiating groups and items\nfunction isUsingGroups<ItemType>(\n  isGrouped: boolean,\n  items: ItemType[] | GenericGroupType<ItemType>[],\n): items is GenericGroupType<ItemType>[] {\n  return isGrouped;\n}\n\n/**\n * The Autocomplete is a component that will show a `TextInput` where a user can type any word which will be used\n * to filter a list of items. That list of filtered items will be shown to the user as possible options for the input.\n * Once one of the options is selected, that option becomes the value of the `TextInput`.\n */\nexport const Autocomplete = React.forwardRef(_Autocomplete) as <T>(\n  props: ExpandProps<AutocompleteProps<T>> & {\n    ref?: React.Ref<HTMLDivElement>;\n  },\n) => ReturnType<typeof _Autocomplete>;\n","import React, { HTMLAttributes } from 'react';\nimport { cx } from 'emotion';\nimport { getStringMatch } from '@contentful/f36-utils';\nimport type { UseComboboxGetItemPropsOptions } from 'downshift';\nimport { Text } from '@contentful/f36-typography';\n\nimport { getAutocompleteStyles } from './Autocomplete.styles';\n\ninterface AutocompleteItemsProps<ItemType> {\n  items: ItemType[];\n  elementStartIndex: number;\n  highlightedIndex: number;\n  getItemProps: (\n    options: UseComboboxGetItemPropsOptions<ItemType>,\n  ) => HTMLAttributes<HTMLLIElement>;\n  renderItem: (item: ItemType, inputValue: string) => React.ReactNode;\n  inputValue: string;\n  listMaxHeight?: number;\n}\n\nexport const AutocompleteItems = <ItemType,>(\n  props: AutocompleteItemsProps<ItemType>,\n) => {\n  const {\n    items,\n    elementStartIndex,\n    highlightedIndex,\n    getItemProps,\n    renderItem,\n    inputValue,\n    listMaxHeight = 180,\n  } = props;\n\n  const styles = getAutocompleteStyles(listMaxHeight);\n\n  return (\n    <ul className={styles.list} data-test-id=\"cf-autocomplete-list\">\n      {items.map((item: ItemType, index: number) => {\n        const itemIndex = elementStartIndex + index;\n        const itemProps = getItemProps({ item, index: itemIndex });\n        return (\n          <Text\n            {...itemProps}\n            as=\"li\"\n            key={itemIndex}\n            className={cx([\n              styles.item({}),\n              highlightedIndex === itemIndex && styles.highlighted,\n            ])}\n            data-test-id={`cf-autocomplete-list-item-${itemIndex}`}\n          >\n            {renderItem ? (\n              renderItem(item, inputValue)\n            ) : typeof item === 'string' ? (\n              <HighlightedItem item={item} inputValue={inputValue} />\n            ) : (\n              item\n            )}\n          </Text>\n        );\n      })}\n    </ul>\n  );\n};\n\nAutocompleteItems.displayName = 'AutocompleteItems';\n\nfunction HighlightedItem({\n  item,\n  inputValue,\n}: {\n  item: string;\n  inputValue: string;\n}) {\n  const { before, match, after } = getStringMatch(item, inputValue);\n\n  return (\n    <>\n      {before}\n      <b>{match}</b>\n      {after}\n    </>\n  );\n}\n\nHighlightedItem.displayName = 'HighlightedItem';\n","import { css, cx } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\nimport { getMenuItemStyles } from '@contentful/f36-core';\n\nexport const getAutocompleteStyles = (listMaxHeight: number) => ({\n  autocomplete: css({\n    position: 'relative',\n    width: '100%',\n  }),\n  combobox: css({\n    position: 'relative',\n  }),\n  inputField: css({\n    paddingRight: tokens.spacingXl,\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n  }),\n  toggleButton: css({\n    position: 'absolute',\n    top: '1px',\n    right: '1px',\n    zIndex: 1,\n    padding: tokens.spacing2Xs,\n    minHeight: 'calc(100% - 2px)',\n  }),\n  content: css({\n    overflow: 'auto',\n    maxHeight: `${listMaxHeight}px`,\n  }),\n  list: css({\n    listStyle: 'none',\n    padding: `${tokens.spacingXs} ${tokens.spacing2Xs}`,\n    margin: 0,\n  }),\n  groupTitle: css({\n    padding: `${tokens.spacingXs} ${tokens.spacingM}`,\n    lineHeight: tokens.lineHeightM,\n  }),\n  noMatchesTitle: css({\n    color: tokens.gray500,\n    margin: `${tokens.spacingM} 0 ${tokens.spacingM} 0`,\n  }),\n  item: ({\n    isActive = false,\n    isDisabled = false,\n  }: {\n    isActive?: boolean;\n    isDisabled?: boolean;\n  }) => cx(getMenuItemStyles({ isActive, isDisabled })),\n  highlighted: css({\n    backgroundColor: tokens.gray100,\n  }),\n  hidden: css({\n    display: 'none',\n  }),\n});\n"]}