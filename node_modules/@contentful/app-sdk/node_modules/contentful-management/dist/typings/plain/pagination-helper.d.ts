import type { BasicCursorPaginationOptions, CollectionProp, CursorPaginatedCollectionProp, PaginationQueryOptions } from '../common-types';
export type OffsetBasedParams = {
    query?: PaginationQueryOptions;
};
export type CursorBasedParams = {
    query?: BasicCursorPaginationOptions;
};
type ExpectedParams = OffsetBasedParams | CursorBasedParams;
/**
 * `sys.type` tends to cause type clashes downstream because it more commonly types less strict
 * as 'string'. Because we don't rely on it for this functionality, we are fine with omitting it.
 */
type IterableCollection<T> = Omit<CollectionProp<T> | CursorPaginatedCollectionProp<T>, 'sys'>;
export type FetchFn<P extends ExpectedParams, T = unknown> = (params: P) => Promise<IterableCollection<T>>;
type ParamsType<P extends ExpectedParams, T extends FetchFn<P>> = T extends (params: infer P) => unknown ? P : never;
/**
 * Parameters for endpoint methods that can be paginated are inconsistent, `fetchAll` will only
 * work with the more common version of supplying the limit, skip, and pageNext parameters via a distinct `query` property in the
 * parameters.
 */
export declare function fetchAll<Params extends ExpectedParams, Entity, F extends FetchFn<Params, Entity>>(fetchFn: FetchFn<Params, Entity>, params: ParamsType<Params, F>): Promise<Entity[]>;
export {};
