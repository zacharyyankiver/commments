function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
import chai, { expect } from 'chai';
import { describe } from 'mocha';
import Sinon from 'sinon';
import { createClient } from '../contentful-management';
import sinonChai from 'sinon-chai';
import { CommentNode } from '../entities/comment';
chai.should();
chai.use(sinonChai);
describe('Plain Client', () => {
  const stub = Sinon.stub();
  beforeEach(() => stub.reset());
  const apiAdapter = {
    makeRequest: args => {
      return stub.returns(Promise.resolve())(args);
    }
  };
  const plainClient = createClient({
    apiAdapter
  }, {
    type: 'plain'
  });
  describe('Comment', () => {
    describe('when body is plain text', () => {
      const props = {
        commentId: '123',
        entryId: '123',
        bodyFormat: 'plain-text'
      };
      const updateText = 'My new text';
      it('should create a get object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.get(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'get',
          params: props,
          payload: undefined,
          headers: undefined
        });
      }));
      it('should create a getMany object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.getMany(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'getMany',
          params: props,
          payload: undefined,
          headers: undefined
        });
      }));
      it('should create a create object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.create(props, {
          body: updateText
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'create',
          params: props,
          payload: {
            body: updateText
          },
          headers: undefined
        });
      }));
      it('should create a update object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.update(props, {
          body: updateText,
          sys: {
            version: 2
          }
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'update',
          params: props,
          payload: {
            body: updateText
          },
          headers: undefined
        });
      }));
      it('should create a delete object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.delete(_objectSpread(_objectSpread({}, props), {}, {
          version: 2
        }));
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'delete',
          params: props,
          payload: undefined,
          headers: undefined
        });
      }));
    });
    describe('when body is rich text', () => {
      const richTextBody = {
        data: {},
        nodeType: CommentNode.Document,
        content: [{
          nodeType: CommentNode.Paragraph,
          data: {},
          content: [{
            nodeType: 'text',
            marks: [],
            data: {},
            value: 'My comment'
          }, {
            nodeType: CommentNode.Mention,
            data: {
              target: {
                sys: {
                  type: 'Link',
                  id: '123',
                  linkType: 'User'
                }
              }
            },
            content: [{
              nodeType: 'text',
              marks: [],
              data: {},
              value: 'My mention'
            }]
          }, {
            data: {},
            marks: [],
            value: '.',
            nodeType: 'text'
          }]
        }]
      };
      const props = {
        commentId: '123',
        entryId: '123',
        bodyFormat: 'rich-text'
      };
      it('should create a get object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.get(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'get',
          params: props,
          payload: undefined,
          headers: undefined
        });
      }));
      it('should create a getMany object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.getMany(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'getMany',
          params: props,
          payload: undefined,
          headers: undefined
        });
      }));
      it('should create a create object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.create(props, {
          body: richTextBody
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'create',
          params: props,
          payload: {
            body: richTextBody
          },
          headers: undefined
        });
      }));
      it('should create a update object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.update(props, {
          body: richTextBody,
          sys: {
            version: 2
          }
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'update',
          params: props,
          payload: {
            body: richTextBody
          },
          headers: undefined
        });
      }));
      it('should create a delete object', /*#__PURE__*/_asyncToGenerator(function* () {
        yield plainClient.comment.delete(_objectSpread(_objectSpread({}, props), {}, {
          version: 2
        }));
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'delete',
          params: props,
          payload: undefined,
          headers: undefined
        });
      }));
    });
  });
});